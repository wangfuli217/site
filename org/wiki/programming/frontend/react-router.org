#+SETUPFILE: ~/site/tpl/wiki-tpl.org
#+TITLE: React Router
#+DATE: 2019-11-27 14:41:40

[[https://reacttraining.com/react-router/web/guides/quick-start][react-router]]

* 主要组件
React Router 主要分三类组件：

- 路由器（routers），比如 =<BrowserRouter>= 和 =<HashRouter>=
- 路由匹配，比如 =<Route>= 和 =<Switch>=
- 导航（Navigation），比如 =<Link>=, =<NavLink>= 和 =<Redirect>= ，也成为路由变更

所有的组件，都需要从 =react-router-dom= 库中导入。

** 路由器

路由组件的核心是 React Router，对于 Web 项目， =react-router-dom= 提供了 =<BrowserRouter>= 和 =<HashRouter>= 两种 routers。
主要区别在于他们存储 URL 和与服务器通信的方式。

- =<BrowserRouter>= 使用正常的 URL 路径，要求正确的配置服务器地址
- =<HashRouter>= 讲当前的路径存储再 hash 部分中，网址看起来是这样的 =http://example.com/#/your/page= 。
  hash 值不会发送到服务器中，也就意味着不需要特殊的服务器配置。

使用 Router 要确保顶层的 =<App />= 放在 Router 之中，如下：

#+BEGIN_SRC javascript
import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter } from "react-router-dom";

function App() {
  return <h1>Hello React Router</h1>;
}

ReactDOM.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  document.getElementById("root")
);
#+END_SRC

** 路由匹配

有两个路由匹配组件： =Switch= 和 =Route= 。当 =<Switch>= 渲染的时候，它会搜索它的 _子_ =<Route>= 元素，找到与当前 URL 匹配的元素。
匹配到之后就会忽略其他的路由。也就意味着特殊的路径要放在不特殊路径的 *前面* 。

如果找不到匹配项， =<Switch>= 会什么都不渲染（null）。

值得注意的是， =<Route path>= 只会匹配 URL 的 *开头* ，不是全部。所以 ~<Route path="/">~ 总是会匹配所有的 URL。
因为这个原因，我们通常把它放在 =<Switch>= 的最后。另外一个解决办法是使用 =exact= 参数，全部匹配路径，比如： ~<Route exact path="/">~ 。

** 路由变更（Nav）

React Router 提供了 =<Link>= 组件来创建链接。当使用 =<Link>= 的时候，会渲染成 anchor（ =<a>= ）。

=<NavLink>= 是 =<Link>= 的一种特殊类型，当其 prop 与当前位置匹配时，可以将其自身设置为「活动」。比如：

#+BEGIN_SRC html
<NavLink to="/react" activeClassName="hurray">
  React
</NavLink>
#+END_SRC

可以用于对当前选中的页面做一些特殊的样式设置之类的。

如果想要强制导航，你可以使用 =<Redirect>= 。当渲染的时候，它会使用 prop 进行导航。

* TODO 服务端渲染（Server Rendering）
* 代码拆分（Code Splitting）

代码拆分可以理解成代码按需加载。为了实现这个目标，需要使用 webpack， =@babel/plugin-syntax-dynamic-import= 和 loadable-components。

webpack 默认支持动态导入；但是，你如果使用了 Babel（比如：把 JSX 编译成 JavaScript），那么你就需要使用 @babel/plugin-syntax-dynamic-import 插件。
这只是一个语法插件，意味着 Babel 不会做任何额外的转换。该插件仅允许 Babel 解析动态导入，因此 webpack 可以将 bundle 他们作为代码拆分。你的 =.babelrc= 可能长这样：

#+BEGIN_SRC javascript
{
  "presets": ["@babel/preset-react"],
  "plugins": ["@babel/plugin-syntax-dynamic-import"]
}
#+END_SRC

loadable-components 是一个库加载组件用来动态导入。它自动处理各种边缘情况，使代码拆分变的很简单。下面是使用范例：

#+BEGIN_SRC javascript
import loadable from "@loadable/component";
import Loading from "./Loading.js";

const LoadableComponent = loadable(() => import("./Dashboard.js"), {
  fallback: <Loading />
});

export default class LoadableDashboard extends React.Component {
  render() {
    return <LoadableComponent />;
  }
}
#+END_SRC
* TODO Scroll Restoration
* TODO Philosophy
* TODO Testing
* TODO Redux Integration
* TODO Static Routes
