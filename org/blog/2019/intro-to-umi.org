#+SETUPFILE: ~/site/tpl/site-tpl.org
#+TITLE: 基于 umi 构建中后台前端项目入门
#+DATE: 2019-12-15 11:04:29

* 目标

相比于后端（甚至是 App、小程序开发）而言，前端发展到现在还没有一个相对成熟稳定的姿态。
Web 前端开发并不难，JS/HTML/CSS 也都很好理解，但是从学习到可以开始写生产代码，曲线比较陡峭。根源在于组件、框架、工具等比较混乱，变更又很快。
对于初学者有了基础知识之后就不知道怎么选择、怎么再进一步。

本文的目标在于帮助那些有一定的程序设计经验的后端开发或者运维，利用 umi 可以快速上手写一些前端项目。

虽然陆陆续续写前端有四五年了，但都是迫于产品化前端资源匮乏的情况下，才写的（大部分在写后端）。所以，我不是一个专职的前端。
从 2018 年开始用 React 全家桶写，本文的很多思路也是基于这个经历。所以目标更在于「启发」而非面面俱到的「教程」。

* 需要了解的前置技术

一点前端技术都不想学就开始写，那是不可能的。所以一些前端基础还是要有的。放心，基础技术都很简单。

** 必须要了解的

- 前端三剑客：
  + ES6/ES7： [[https://es6.ruanyifeng.com/][ECMAScript 7 入门]]，把前几章看完就行了，掌握基本语法。大约需要 1 小时
  + CSS： MDN 的文档 [[https://developer.mozilla.org/zh-CN/docs/Web/CSS][CSS（层叠样式表）]]很不错，有时间通读；[[https://book.douban.com/subject/2308234/][CSS权威指南（第三版）]] 这本书很好
  + HTML：MDN 的文章 [[https://developer.mozilla.org/zh-CN/docs/Web/HTML][HTML（超文本标记语言）]]很不错，有时间通读
- React：Facebook 开源的、时下最热的前端框架，[[https://zh-hans.reactjs.org/tutorial/tutorial.html][官方文档]]，一定要通读一遍，但是例子没必要全部实现。跟学 JavaScript 一样，有那些东西，基本的语法是要有的
- LESS：LESS 是对 CSS 的一层抽象，使用的时候最终还是会转换成 CSS，[[http://lesscss.org/usage/][官方文档]]，建议了解其基本语法
- [[https://www.npmjs.com/][npm]]/[[https://yarnpkg.com/lang/en/][yarm]]：包管理和构建工具

说明：

- ECMAScript 和 JavaScript 的关系：ES 一种规范，而 JS 是实现（其他实现还有 ActionScript），很多时候 ES 和 JS 是混用的，等价成一个东西。
  ES6 和 ES2015 也是同一个东西，只是叫法不一样。
- HTML/CSS 是前端基础中的基础，*必须* 要了解其基本语法，但是他们真的简单，不要有心里压力。HTML 没有太多可说的，对于 CSS 要掌握的有：
  + 基础：颜色、字体、文字样式、对齐、阴影 /简单，1 个小时足够/
  + 选择器：类选择器、ID 选择器、属性选择器、伪类和伪元素 /简单，两个小时学习足够/
  + HTML 结构和样式层叠关系 /会有点绕，但都是些语法/
  + 盒模型： =margin= =padding= =border= 这是布局的基础 /简单，一个小时足够/
  + 布局：常用的几种定位方式， float 布局难，flex 布局很好理解很好操作。/整体有点难度，但是可以跳过/
- 了解 CSS 之后，LESS 只要看一遍就不用再看了，给你一个例子立马就明白了：
  #+BEGIN_SRC css
  .main-menu {
    padding: 20px 0;
    background: #e2e2e2;
  }

  .main-menu > .navigation {
    display: inline-block;
    padding: 20px 0;
    width: 30%;
    font-style: 15px;
    color: #333;
  }

  .main-menu > .navigation:hover {
    text-decoration: none;
    color: #0a6c9f;
    background: #e2e2e2;
  }
  #+END_SRC
  这是 CSS 写法，下面 LESS 的写法：
  #+BEGIN_SRC css
  @background-color: #e2e2e2;
  @padding: 20px 0;

  .main-menu {
    & {
      padding: @padding;
      background: @background-color;
    }

    > .navigation {
      display: inline-block;
      padding: @padding;
      width: 30%;
      font-style: 15px;
      color: #333;
      &:hover {
        text-decoration: none;
        color: #0a6c9f;
        background: @background-color;
      }
    }
  }
  #+END_SRC
  可以理解成 LESS 是 CSS 的预编译语言，最后都会转成 CSS 来运行，而且在 LESS 中写 CSS 的语法也一点问题都没有。

** 可选的要了解的

当然前提是 React 技术栈，不然那可就多了。

- [[https://nodejs.org/zh-cn/][node.js]] 是一个基于 Chrome V8 引擎 的 JavaScript 运行时
- [[https://reacttraining.com/react-router/web/guides/quick-start][react-router]] URL 路由器：负责把一个 URL 路径绑定到一个 React 组件上 /好理解/
- [[https://redux.js.org/][redux]] JavaScript 可预测的状态容器，[[https://react-redux.js.org/][react-redux]] 是 React 的实现  /难理解/
- [[https://github.com/redux-saga/redux-saga][redux-saga]] 他是 redux 的中间件 /难理解/

说明：

- 早起 JavaScript 离开浏览器是不能运行的，node 使得在他可以像 Python 一样在命令行也可以运行，可以写 server 端；这使得 JavaScript 更加的工程化
- 可预测的状态容器不好理解，但是我理解的是他解决的是组件之间数据通信、状态的问题：
  + =store= 用来存储状态（数据）
  + =action= 改变状态的动作（向后端请求、或者 A 组件的变化影响 B 组件）
  + =reducer= =action= 的结果处理，修改 =store= ，生成新的 =store=
  redux 语法很晦涩，redux-saga 目的是更优雅的管理 Side Effects （比如异步请求）
- redux + redux-saga 还是很难理解，[[https://dvajs.com/guide/][dva]] 整合了 redux 和 redux-saga 用起来就很舒服了

*刚开始学不用深入了解每一个关联技术的工作原理，只要知道他的存在目的是什么，是为了解决什么问题。*
* React 简介

官方提供了丰富的文档，还有配套的案例，比我写的好多了，所以不再赘述。这里只说一下我所理解的 React 到底干了什么事情。

下面是一个点击按钮，数值自增的例子，用 jQuery 实现是这样的：

#+BEGIN_SRC javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script>
      $(document).ready(function() {
        $("button").click(function() {
          var count = $("#count").text();
          $("#count").text(parseInt(count) + 1);
        });
      });
    </script>
  </head>
  <body>
    <div>
      init value is: <span style="color: red" id="count">0</span>
      <br />
      <button>点我</button>
    </div>
  </body>
</html>
#+END_SRC

demo: https://codesandbox.io/s/click-one-jquery-guim0

如果用 React 实现是这样的：

#+BEGIN_SRC javascript
import React, { Component } from "react";
import ReactDOM from "react-dom";

class ClickPlusOne extends Component {
  state = {
    count: 0
  };
  click = () => {
    this.setState({
      count: this.state + 1,
    })
  };

  render() {
    const { count } = this.state;
    return (
      <div>
        init value is: <span style={{ color: "red" }}>{count}</span>
        <br />
        <button onClick={this.click}>请点我</button>
      </div>
    );
  }
}

function App() {
  return (
    <div className="App">
      <ClickPlusOne />
    </div>
  );
}

const rootElement = document.getElementById("root");
ReactDOM.render(<App />, rootElement);
#+END_SRC

demo: https://codesandbox.io/s/click-plus-react-uh290

在上面的基础上再加一个功能，根据数量渲染一个列表出来。对于 jQuery：

#+BEGIN_SRC javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script>
      $(document).ready(function() {
        $("button").click(function() {
          var count = $("#count").text();
          $("#count").text(parseInt(count) + 1);

          var listHtml = [];
          for (var i = 0; i < count; i++) {
            listHtml += `<li>item: ${i + 1}</li>`;
          }
          $("#list").html(listHtml);
        });
      });
    </script>
  </head>
  <body>
    <div>
      init value is: <span style="color: red" id="count">0</span> <br />
      <button>点我</button>
      <ul id="list"></ul>
    </div>
  </body>
</html>
#+END_SRC

https://codesandbox.io/s/click-jquery-list-fww7j

对于 React：

#+BEGIN_SRC javascript
import React, { Component } from "react";
import ReactDOM from "react-dom";

class ClickPlusOne extends Component {
  state = {
    count: 0
  };

  click = () => {
    this.setState({
      count: this.state.count + 1
    });
  };

  createList = () => {
    const { count } = this.state;
    const children = [];
    for (let i = 0; i < count; i++) {
      children.push(<li key={i}>item: {i + 1}</li>);
    }
    return children;
  };

  render() {
    const { count } = this.state;
    return (
      <div>
        init value is: <span style={{ color: "red" }}>{count}</span>
        <br />
        <button onClick={this.click}>请点我</button>
        <ul>{this.createList()}</ul>
      </div>
    );
  }
}

function App() {
  return (
    <div className="App">
      <ClickPlusOne />
    </div>
  );
}

const rootElement = document.getElementById("root");
ReactDOM.render(<App />, rootElement);
#+END_SRC

demo: https://codesandbox.io/s/click-plus-react-list-ugws4

上面这两个例子，可以看到：

- 不管是 jQuery 还是 React 的实现方式，他们都干的事情是：当数据变更时，修改 DOM 结构（内容），这个过程可以称之为「渲染」
- React 代码并不比 jQuery 的代码少，只不过写起来更加优雅一些。尤其是业务逻辑复杂之后，React 代码结构更清晰
  我个人以为：React 更加符合后端程序思维方式

这两个例子反映不到的是：

- React 是 _单向数据_ 流的，当 state（组件内部） 和 props（传入）发生变更时，触发渲染
- 在 React 中一切都是组件，每个组件都有自己的生命周期 [[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/][react-lifecycle-methods-diagram]]，在每个生命周期函数中都可以做一些事情，比如：
  + 在 =componentDidMount= 时，异步向后端请求数据
  + 在 =render= 时，返回渲染之后的 DOM 结构
  + 在 =componentDidUpdate= 时，判断数据变更，重新请求数据
  + 在 =componentWillUnmount= 时，卸载数据

React _并不是_ 完整的前端框架解决方案，他只是提供了高效的 DOM 渲染（同样 vue.js 也是如此），脚手架解决方案。
React 官方的脚手架是 [[https://github.com/facebook/create-react-app][create-react-app]]。
* 脚手架（scaffold）

经常写后端人知道后端有 Web 框架，比如：Python 的 Django，flask；Java 的 Sprint Boot；Go 的 Gin 等。一个后端的框架一般会包含那些呢？

- 接入层（网络层），负责与外部通信协议命令字转换等
- 路由层（Router），API 映射到具体的业务逻辑 handler
- 逻辑处理层（Viewer），处理业务逻辑
- 缓存层（Cache），页面数据缓存
- 模型层（Model），定义数据库表，对数据库基本操作 CRUD 提供易用的接口
- 其他：统一异常处理，日志系统，监控，调优工具等
- 构建部署工具

（如果是微服务框架，还会提供服务注册，服务发现等能力）。

不同的语言的框架，或者说不同业务场景产生的框架包含的内容不一样。但其目的都是：为了减少重复工作而提供的模块、工具抽象。

对于前端也是类似，只不过前端一般叫 Scaffold，即脚手架。
这个神秘的词汇，如果你查一下维基百科，[[https://en.wikipedia.org/wiki/Scaffold_(programming)][Scaffold (programming)]] 就会发现他和 framework 基本上是一个东西。所以... 别想那么多了。就是前端框架。

（我自己 yy 过为什么前端叫脚手架而不叫框架，大约是因为前端的概念用的太乱了，组件，框架乱飞，但是干的事情又不太一样，比如 Bootstrap 也叫框架，React 也叫框架 ...）

一个前端脚手架一般会包含这些部分：

- 网络请求层（request）：与后端异步通信（一般是 HTTP 请求），比较出名的有 [[https://github.com/github/fetch][fetch]]，[[https://github.com/axios/axios][axios]]；通常会对基础库再封装一层，然后提供统一的错误处理；
- 路由层（Router）：浏览器中访问的每一个 URL 对应的逻辑处理组件，比如 [[https://reacttraining.com/react-router/web/guides/quick-start][react-router]]；还有一种称之为约定式路由，即 URL 路径与目录结构一一对应；
- 逻辑处理层（Viewer）：具体的页面逻辑和渲染
- 各种浏览器兼容转换
  + TypeScript 转换成 JavaScript
  + 将 ES6/ES7 转换成 ES5，一般使用 [[https://babeljs.io/][babel]]
  + 将 LESS/SASS 转换成 CSS
- 构建打包、性能优化：一般是对 [[https://webpack.js.org/][webpack]] 的二次封装；代码分割；代码打包压缩，代码混淆

其实可以看出前端所干的事情比后端要少很多，而且远没有后端那么成熟，类似运行兼容这种应该是语言层面应该解决的问题，不应该框架来解决。但其目标也是为了减少重复工作。

* umi

[[https://umijs.org/][umi]] 是蚂蚁金服开源的企业级的基于 React 技术栈的应用框架。他的定位类似与 create-react-app，除了上面说的一般脚手架所包含的部分之外，他还集成了：

- [[https://ant.design/index-cn][antd]]：基于 React 的 UI 组件库（类似 Bootstrap，只不过 Bootstrap 是用 JS 实现的）
- [[https://dvajs.com/guide/][dva]]：基于 redux 和 redux-saga 的数据流方案，简化使用 redux 成本； umi 融合了 dva，并且提供了 model 自动加载等，又简化了 dva 的使用成本；

** ant design pro 与 umi

其实我一开始是不知道 umi 的，只知道 Ant Design Pro。从 Pro 0.x/1.0 到 Pro 4.0（umi） 只不过短短的两年多时间，只能感叹发展太快了，我恰好在挖财做云平台完整的经历了从 Pro 到 umi 的蜕变。

这期间躺了很多坑，也在 issue 上吐槽了。然而，最终的结果还是比较令人满意的。大体的发展图是这样的：

https://blog-1252349778.cos.ap-beijing.myqcloud.com/2019/from-pro-umi.png

** TODO umi 安装
** TODO 目录结构
** TODO 实例：一个页面的生命周期
** TODO 部署
* TODO 结语
